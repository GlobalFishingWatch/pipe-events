#StandardSQL

-- contains_point
--
-- returns True if the given (lat,lon) is within the bounding box described
-- by (lat1,lon1) (lat2,lon2)
-- Handles the case where the bbox spans the antimeridian

CREATE TEMPORARY FUNCTION contains_point(lat FLOAT64, lon FLOAT64,
          lat1 FLOAT64, lon1 FLOAT64, lat2 FLOAT64, lon2 FLOAT64)
RETURNS BOOL
LANGUAGE js AS """
  var contains_lat, contains_lon

  contains_lat = (lat >= Math.min(lat1, lat2)) && (lat <= Math.max(lat1, lat2));

  if (Math.abs(lon2 - lon1) > 180) {
    contains_lon = (lon <= Math.min(lon1, lon2)) || (lon >= Math.max(lon1, lon2))
  }
  else {
    contains_lon = (lon >= Math.min(lon1, lon2)) && (lon <= Math.max(lon1, lon2));
  }

  return contains_lat && contains_lon;

""";


-- interpolate_position
--
-- Computes a linearly interpolated position along the line from (lat1,lon1) to (lat2,lon2), using
-- the difference between t, t1 and t2 such that the spatial distance from (lat1,lon1) to the
-- result (lat,lon) is proportional to (t - t1) / (t2 - t1).   It is assumed that t1 <= t <= t2.
--
-- This is done with a naive cartesian distance in degrees, and needs to be replaced with a real
-- great circle computation
--
-- Handles the case where the interpolation line spans the antimeridian
-- The result will have -180 >= lon < 180
--
-- delta_s is the distance from the closest point to the computed lat/lon in meters

CREATE TEMPORARY FUNCTION interpolate_position (t FLOAT64,
          lat1 FLOAT64, lon1 FLOAT64, t1 FLOAT64,
          lat2 FLOAT64, lon2 FLOAT64, t2 FLOAT64)
RETURNS STRUCT<lat FLOAT64, lon FLOAT64, delta_t FLOAT64, dist_m FLOAT64>
LANGUAGE js AS """
  function toRad(x) {
     return x * Math.PI / 180;
  }

  function haversine_distance_m(lat1,lon1, lat2, lon2) {
    var R = 6371; // km
    var dLat = toRad(lat2-lat1);
    var dLon = toRad(lon2-lon1);
    var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    var d = R * c;

    return d * 1000
  }

  var result = {lat: 0.0, lon: 0.0, delta_t: 0.0, delta_s: 0.0}
  var offset = (t - t1) / (t2 - t1)

  /* Unwrap the dateline */
  if (Math.abs(lon2 - lon1) > 180) {
    lon2 = lon2 - (Math.sign(lon2) * 360)
  }

  result.lat = lat1 + ((lat2 - lat1) * offset)
  result.lon = lon1 + ((lon2 - lon1) * offset)

  /* compute distance to the point that is nearest in time */
  if (Math.abs(t - t1) < Math.abs(t - t2)) {
    result.delta_t = t - t1
    result.dist_m = haversine_distance_m(result.lat, result.lon, lat1, lon1)
  }
  else {
    result.delta_t = t2 - t
    result.dist_m = haversine_distance_m(result.lat, result.lon, lat2, lon2)
  }

  /* wrap the dateline if necessary */
  if (result.lon >= 180.0) {
    result.lon -= 360.0
  } else if (result.lon < -180.0) {
    result.lon += 360.0
  }

  return result;

""";

WITH
  -- get the vessel positions to be correlated.  Include a buffer from the day before the target date range so
  -- we can get a previous position for all vessel points in the range
  vessel_position as (
    SELECT
      vessel_id,
      seg_id,
      timestamp,
      lat,
      lon
    FROM
      `{{vessel_positions}}*`
    WHERE
      _TABLE_SUFFIX BETWEEN
        FORMAT_DATE("%Y%m%d", DATE_SUB( DATE "{{ start_date }}", INTERVAL 1 DAY) ) AND
        FORMAT_DATE("%Y%m%d", DATE "{{ end_date }}" )
  ),

  -- Get a set of noise segments to use to filter vessel positions
  noise_segment as (
    SELECT
      seg_id
    FROM
      `{{ segments }}*`
    WHERE
      _TABLE_SUFFIX BETWEEN
        FORMAT_DATE("%Y%m%d", DATE "{{ start_date }}" ) AND
        FORMAT_DATE("%Y%m%d", DATE "{{ end_date }}" )
      AND noise
    GROUP BY seg_id
  ),

  -- Get the detections to be matched with vessels
  detection as (
    SELECT
      id_Key as  detection_id,
      Date_Mscan as timestamp,
      Lat_DNB as lat,
      Lon_DNB as lon
    FROM `world-fishing-827.pipe_staging_a.raw_vbd`
    WHERE
      DATE(_PARTITIONTIME) BETWEEN
         DATE "{{ start_date }}" AND
         DATE "{{ end_date }}"
      AND QF_Detect = 1
  ),

  -- Make pairs of consecutive vessel points within segments after filtering out noise
  vessel_point_pair as (
    SELECT
      v.*,
      LAG(timestamp) OVER (PARTITION BY seg_id ORDER BY timestamp) AS prev_timestamp,
      LAG(lat) OVER (PARTITION BY seg_id ORDER BY timestamp) AS prev_lat,
      LAG(lon) OVER (PARTITION BY seg_id ORDER BY timestamp) AS prev_lon
    FROM
      vessel_position v
    LEFT OUTER JOIN
      noise_segment s
    USING (seg_id)
    WHERE
      s.seg_id is NULL
  ),

  -- Find detections that fall within the spatial and temporal extent of a vessel point pair
  -- and filter out vessel points from the buffer day
  candidate_match as (
    SELECT
      v.*,
      d.detection_id,
      d.timestamp as d_timestamp,
      d.lat as d_lat,
      d.lon as d_lon
    FROM
      vessel_point_pair v
    JOIN
      detection d
    ON
      d.timestamp BETWEEN v.prev_timestamp AND v.timestamp
      AND DATE(v.timestamp) BETWEEN DATE "{{ start_date }}" AND DATE "{{ end_date }}"
      AND contains_point(d.lat, d.lon, v.prev_lat, v.prev_lon, v.lat, v.lon)
  ),

  -- Compute the interpolated vessel position for the timestamp of each candidate detection
  interpolated_position as (
    SELECT
      *,
      interpolate_position (
        UNIX_MICROS(d_timestamp)/1000000.0,
        prev_lat, prev_lon, UNIX_MICROS(prev_timestamp)/1000000.0,
        lat, lon, UNIX_MICROS(timestamp)/1000000.0
        ) as interpolated
    FROM
      candidate_match
  ),

  -- Filter matched detections to only ones where delta_t is less than 1 hour
  -- and distance is less than 500m
  -- compute a normalized match score [0.0, 1.0]
  correlated_detection as (
    SELECT
      *,
      1.0 / (1.0 + (interpolated.delta_t/3600) + (interpolated.dist_m/500)) as match_score
    FROM
      interpolated_position
    WHERE
      interpolated.delta_t <= 3600
      AND interpolated.dist_m <= 500
  )

SELECT
  *
FROM
  correlated_detection

-- Test queries
-- select contains_point(33.790409,	125.898773, 33.71407,	118.3526683333,	33.8533816667,	118.6474216667)
-- select
--   interpolate_position (0, 0,0,0, 1,1,1),
--   interpolate_position (1, 0,0,0, 2,0,2),
--   interpolate_position (2, 10,0,0, 0,1,10),
--   interpolate_position (2, 10,-179,0, 0,179,10),
--   interpolate_position (7, 10,-179,0, 0,179,10),
--   interpolate_position (7, 10,179,0, 0,-179,10)

LIMIT 1000
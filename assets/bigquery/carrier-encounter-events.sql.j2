#standardSQL
{% include 'util.sql.j2' %}
--
-- Converts a UVI to the RFMO authorizations apply to
--
CREATE TEMPORARY FUNCTION
  extract_rfmo_from_list_uvi(uvi STRING) AS (
    CASE SPLIT(uvi, "-")[
  OFFSET
    (0)]
      WHEN "TWN3" THEN "IOTC"
      WHEN "WCPFC" THEN "WCPFC"
      WHEN "WCPFC2" THEN "WCPFC"
      WHEN "IATTC" THEN "IATTC"
      WHEN "IATTC2" THEN "IATTC"
      WHEN "IATTC3" THEN "IATTC"
      WHEN "ICCAT" THEN "ICCAT"
      WHEN "ICCAT2" THEN "ICCAT"
      WHEN "ICCAT3" THEN "ICCAT"
      WHEN "IOTC" THEN "IOTC"
      WHEN "CCSBT" THEN "CCSBT"
  END
    );
--
-- Returns true an rfmo is whitelisted so that authorizations should be
-- computed for it
--
CREATE TEMPORARY FUNCTION
  is_whitelisted_rfmo(rfmo STRING) AS ( rfmo IN ( "ICCAT",
      "IOTC",
      "WCPFC",
      "IATTC",
      "CCSBT" ) );
WITH
  --
  -- Declare the source tables we are going to use through the entire query
  --
  source_encounters AS (
  SELECT
    *
  FROM
    `{{ source_table }}`
  {% if source_filter %}
  WHERE
    {{ source_filter }}
  {% endif %}
  ),
  source_vessel_info AS (
  SELECT
    *
  FROM
    `{{ vessel_info }}`),
  source_vessel_database AS (
  SELECT
    *
  FROM
    `{{ vessel_database }}`),
  source_spatial_measures AS (
  SELECT
    *
  FROM
    `{{ spatial_measures }}`),
  source_country_codes AS (
  SELECT
    *
  FROM
    `{{ country_codes }}` ),
  source_voyages AS (
  SELECT
    *
  FROM
    `{{ voyages }}`),
  source_anchorages AS (
  SELECT
    *
  FROM
    `{{ named_anchorages }}`),
  source_fishing_vessels AS (
  SELECT
    *
  FROM
    `{{ fishing_vessels }}`),
  --
  -- We need to flatten voyages so that we have a record for each vessel id
  --
  flattened_voyages AS (
  SELECT
    trip_id,
    trip_start,
    trip_end,
    trip_start_anchorage_id,
    trip_end_anchorage_id,
    vessel_id
  FROM
    source_voyages
  CROSS JOIN
    UNNEST(vessel_ids) AS vessel_id ),
  --
  -- Good encounter events
  --
  encounters AS (
  SELECT
    *
  FROM
    source_encounters
  WHERE
    TIMESTAMP_DIFF(end_time, start_time, SECOND) > (3600 * 2)
    AND median_speed_knots < {{ max_median_speed_knots }}),
  --
  -- Only consider encounters between a carrier and fishing vessel. To
  -- determine if each vessel is a carrier or a fishing vessel, we need to join
  -- both vessel id's to the corresponding records in the vessel database and
  -- in the fishing list. Include in the resulting table information pulled
  -- from the vessel database, including if each vessel is a carrier or not and
  -- the registry information.
  --
  filtered_encounters AS (
  SELECT
    encounters.*,
    vessel_database_1.is_carrier AS vessel_1_is_carrier,
    vessel_database_2.is_carrier AS vessel_2_is_carrier,
    vessel_database_1.registry AS vessel_1_registry,
    vessel_database_2.registry AS vessel_2_registry
  FROM
    encounters
  INNER JOIN
    source_vessel_info AS vessel_info_1
  ON
    encounters.vessel_1_id = vessel_info_1.vessel_id
  INNER JOIN
    source_vessel_info AS vessel_info_2
  ON
    encounters.vessel_2_id = vessel_info_2.vessel_id
  LEFT JOIN
    source_vessel_database AS vessel_database_1
  ON
    vessel_info_1.ssvid = vessel_database_1.identity.ssvid
    AND encounters.start_time > (
    SELECT
      MIN(first_timestamp)
    FROM
      vessel_database_1.activity)
    AND encounters.end_time < (
    SELECT
      MAX(last_timestamp)
    FROM
      vessel_database_1.activity)
    AND vessel_database_1.matched
  LEFT JOIN
    source_vessel_database AS vessel_database_2
  ON
    vessel_info_2.ssvid = vessel_database_2.identity.ssvid
    AND encounters.start_time > (
    SELECT
      MIN(first_timestamp)
    FROM
      vessel_database_2.activity)
    AND encounters.end_time < (
    SELECT
      MAX(last_timestamp)
    FROM
      vessel_database_2.activity)
    AND vessel_database_2.matched
  LEFT JOIN
    source_fishing_vessels AS fishing_1
  ON
    vessel_info_1.ssvid = fishing_1.ssvid
    AND EXTRACT(year
    FROM
      encounters.start_time) = fishing_1.year
  LEFT JOIN
    source_fishing_vessels AS fishing_2
  ON
    vessel_info_2.ssvid = fishing_2.ssvid
    AND EXTRACT(year
    FROM
      encounters.start_time) = fishing_2.year
  WHERE
    ( vessel_database_1.is_carrier
      AND fishing_2.ssvid IS NOT NULL ) OR
    ( vessel_database_2.is_carrier
      AND fishing_1.ssvid IS NOT NULL ) ),
  --
  -- Duplicate encounters so that we have an event for each vessel.
  --
  flattened_encounters AS (
  SELECT
    vessel_1_id AS vessel_id,
    vessel_1_is_carrier AS vessel_is_carrier,
    vessel_1_registry AS vessel_registry,
    vessel_2_id AS encountered_vessel_id,
    vessel_2_is_carrier AS encountered_vessel_is_carrier,
    CONCAT( TO_HEX(MD5(FORMAT("encounter|%s|%s|%t|%t", vessel_1_id, vessel_2_id, start_time, end_time))), ".1" ) AS event_id,
    * EXCEPT(vessel_1_id, vessel_1_is_carrier, vessel_1_registry, vessel_2_id, vessel_2_is_carrier, vessel_2_registry)
  FROM
    filtered_encounters
  UNION ALL
  SELECT
    vessel_2_id AS vessel_id,
    vessel_2_is_carrier AS vessel_is_carrier,
    vessel_2_registry AS vessel_registry,
    vessel_1_id AS encountered_vessel_id,
    vessel_1_is_carrier AS encountered_vessel_is_carrier,
    CONCAT( TO_HEX(MD5(FORMAT("encounter|%s|%s|%t|%t", vessel_1_id, vessel_2_id, start_time, end_time))), ".2" ) AS event_id,
    * EXCEPT(vessel_1_id, vessel_1_is_carrier, vessel_1_registry, vessel_2_id, vessel_2_is_carrier, vessel_2_registry)
  FROM
    filtered_encounters ),
  --
  -- Calculate authorization data for each vessel, only getting authorization
  -- data for ICCAT, IOTC, WCPFC, IATTC and CCSBT
  --
  authorizations AS (
  SELECT
    vessel_id,
    extract_rfmo_from_list_uvi(registry.list_uvi) AS rfmo,
    registry.authorized_from,
    registry.authorized_to
  FROM
    flattened_encounters
  CROSS JOIN
    UNNEST(vessel_registry) AS registry
  WHERE
    -- Only include authorizations records from whitelisted rfmos
    is_whitelisted_rfmo(extract_rfmo_from_list_uvi(list_uvi))
    AND authorized_from IS NOT NULL
    AND authorized_to IS NOT NULL),
  --
  -- Include additional information on the final event, such as basic vessel
  -- information for each vessel involved in the encounter or regional and
  -- spatial information
  --
  complete_encounter_event AS (
  SELECT
    encounter.*,
    main_vessel.shipname.value AS main_vessel_shipname,
    main_vessel.ssvid AS main_vessel_ssvid,
    main_vessel_country.iso3 AS main_vessel_flag,
    encountered_vessel.shipname.value AS encountered_vessel_shipname,
    encountered_vessel.ssvid AS encountered_vessel_ssvid,
    encountered_vessel_country.iso3 AS encountered_vessel_flag,
    main_vessel_trip_start_anchorages.s2id AS main_vessel_trip_start_anchorage_id,
    main_vessel_trip_start_anchorages.iso3 AS main_vessel_trip_start_iso3,
    main_vessel_trip_start_anchorages.label AS main_vessel_trip_start_label,
    main_vessel_trip_end_anchorages.s2id AS main_vessel_trip_end_anchorage_id,
    main_vessel_trip_end_anchorages.iso3 AS main_vessel_trip_end_iso3,
    main_vessel_trip_end_anchorages.label AS main_vessel_trip_end_label,
    encountered_vessel_trip_start_anchorages.s2id AS encountered_vessel_trip_start_anchorage_id,
    encountered_vessel_trip_start_anchorages.iso3 AS encountered_vessel_trip_start_iso3,
    encountered_vessel_trip_start_anchorages.label AS encountered_vessel_trip_start_label,
    encountered_vessel_trip_end_anchorages.s2id AS encountered_vessel_trip_end_anchorage_id,
    encountered_vessel_trip_end_anchorages.iso3 AS encountered_vessel_trip_end_iso3,
    encountered_vessel_trip_end_anchorages.label AS encountered_vessel_trip_end_label,
    measures.distance_from_shore_m AS distance_from_shore_m,
    measures.distance_from_port_m AS distance_from_port_m,
    measures.elevation_m AS elevation_m,
    measures.regions AS regions
  FROM
    flattened_encounters AS encounter
  INNER JOIN
    source_vessel_info AS main_vessel
  USING
    (vessel_id)
  INNER JOIN
    source_vessel_info AS encountered_vessel
  ON
    encountered_vessel_id = encountered_vessel.vessel_id
  INNER JOIN
    source_spatial_measures AS measures
  ON
    FORMAT("lon:%+07.2f_lat:%+07.2f", ROUND(encounter.mean_longitude/0.01)*0.01, ROUND(encounter.mean_latitude/0.01)*0.01) = measures.gridcode
    AND measures.distance_from_shore_m > 10000
  INNER JOIN
    source_country_codes AS main_vessel_country
  ON
    SUBSTR(main_vessel.ssvid, 1, 3) = CAST(main_vessel_country.code AS string)
  INNER JOIN
    source_country_codes AS encountered_vessel_country
  ON
    SUBSTR(encountered_vessel.ssvid, 1, 3) = CAST(encountered_vessel_country.code AS string)
  LEFT JOIN
    flattened_voyages AS main_vessel_voyages
  ON
    main_vessel.vessel_id = main_vessel_voyages.vessel_id
    AND main_vessel_voyages.trip_start < encounter.start_time
    AND main_vessel_voyages.trip_end > encounter.end_time
  LEFT JOIN
    source_anchorages AS main_vessel_trip_start_anchorages
  ON
    main_vessel_voyages.trip_start_anchorage_id = main_vessel_trip_start_anchorages.s2id
  LEFT JOIN
    source_anchorages AS main_vessel_trip_end_anchorages
  ON
    main_vessel_voyages.trip_end_anchorage_id = main_vessel_trip_end_anchorages.s2id
  LEFT JOIN
    flattened_voyages AS encountered_vessel_voyages
  ON
    encountered_vessel.vessel_id = encountered_vessel_voyages.vessel_id
    AND encountered_vessel_voyages.trip_start < encounter.start_time
    AND encountered_vessel_voyages.trip_end > encounter.end_time
  LEFT JOIN
    source_anchorages AS encountered_vessel_trip_start_anchorages
  ON
    encountered_vessel_voyages.trip_start_anchorage_id = encountered_vessel_trip_start_anchorages.s2id
  LEFT JOIN
    source_anchorages AS encountered_vessel_trip_end_anchorages
  ON
    encountered_vessel_voyages.trip_end_anchorage_id = encountered_vessel_trip_end_anchorages.s2id ),
  --
  -- Flatten and filter the regions where the encounters happen, so that we end
  -- up with a table with multiple records per each encounter, one per rfmo
  -- region where the encounter happened when the region is one of the
  -- interesting rfmos, including authorization status for each of those
  -- regions for both vessels involved.
  --
  encounter_regions_with_authorizations AS (
  SELECT
    encounters.event_id,
    rfmo,
    vessel_authorization.rfmo AS authorized_rfmo,
    encountered_vessel_authorization.rfmo AS encountered_vessel_authorized_rfmo
  FROM
    complete_encounter_event AS encounters
  CROSS JOIN
    UNNEST(encounters.regions.rfmo) AS rfmo
  LEFT JOIN
    authorizations AS vessel_authorization
  ON
    encounters.vessel_id = vessel_authorization.vessel_id
    AND rfmo = vessel_authorization.rfmo
    AND encounters.start_time > vessel_authorization.authorized_from
    AND encounters.end_time < vessel_authorization.authorized_to
  LEFT JOIN
    authorizations AS encountered_vessel_authorization
  ON
    encounters.vessel_id = encountered_vessel_authorization.vessel_id
    AND rfmo = encountered_vessel_authorization.rfmo
    AND encounters.start_time > encountered_vessel_authorization.authorized_from
    AND encounters.end_time < encountered_vessel_authorization.authorized_to
  WHERE
    rfmo IN ("ICCAT",
      "IOTC",
      "WCPFC",
      "IATTC",
      "CCSBT")
  GROUP BY
    encounters.event_id,
    rfmo,
    authorized_rfmo,
    encountered_vessel_authorized_rfmo),
  --
  -- Calculate the final encounter authorization status. An encounter is only
  -- authorized if it's authorized for both vessels in all the rfmos, if it
  -- happened outside an rfmo or in an rfmo we are not interested about.
  --
  encounter_authorizations AS (
  SELECT
    encounters.event_id,
    -- Here we decide if the encounter is authorized or not. The rfmo field
    -- contains a non-null value if the encounter happened inside one of the
    -- interesting rfmos. The vessel_authorized_rfmo and
    -- encountered_vessel_authorized_rfmo fields contains a non-null value if
    -- the encounter happened inside an interesting rfmo and it was authorized
    -- to do so for the main vessel and the encountered vessel respectively. To
    -- sum up:
    --
    --  * if all the records for a given event_id have null rfmo then that
    --  means that it's an encounter happening outside of the interesting
    --  rfmos, so it's authorized.
    --
    --  * If all the records for a given event_id have all fields with
    --  non-null values, it happened inside one or more rfmos of the
    --  interesting rfmos and all the involved vessels were authorized.  
    --
    --  * Any other case means it's an unauthorized encounter
    LOGICAL_AND(encounter_authorizations.rfmo IS NULL)
    OR LOGICAL_AND(encounter_authorizations.rfmo IS NOT NULL AND encounter_authorizations.authorized_rfmo IS NOT NULL AND encounter_authorizations.encountered_vessel_authorized_rfmo IS NOT NULL) AS is_authorized,
    -- We also compute authorization status. We are talking about 3 different
    -- values here:
    --
    --  * An encounter can be authorized on the same conditions as before.
    --
    --  * An encounter can be partially authorized if any of the vessels is
    --  authorized in some of the regions it is happening in.
    --
    --  * An encounter is unauthorized if both vessels are not authorized in
    --  all of the regions it is happening in.
    CASE
      WHEN LOGICAL_AND(encounter_authorizations.rfmo IS NULL) OR LOGICAL_AND(encounter_authorizations.rfmo IS NOT NULL AND encounter_authorizations.authorized_rfmo IS NOT NULL AND encounter_authorizations.encountered_vessel_authorized_rfmo IS NOT NULL) THEN 'authorized'
      WHEN LOGICAL_AND(encounter_authorizations.rfmo IS NOT NULL AND encounter_authorizations.authorized_rfmo IS NULL AND encounter_authorizations.encountered_vessel_authorized_rfmo IS NULL) THEN 'unauthorized'
    ELSE
    'partial'
  END
    AS authorization_status,
    -- Finally, we need to compute per-region authorization status. For each
    -- authorization record in this event, we generate a struct containing the
    -- name of the region and the authorization status for each vessel.
    ARRAY_AGG(STRUCT( encounter_authorizations.rfmo AS `rfmo`,
        encounter_authorizations.authorized_rfmo IS NOT NULL AS `is_authorized`,
        encounter_authorizations.encountered_vessel_authorized_rfmo IS NOT NULL AS `encountered_vessel_is_authorized`)) AS region_authorizations
  FROM
    complete_encounter_event AS encounters
  LEFT JOIN
    encounter_regions_with_authorizations AS encounter_authorizations
  USING
    (event_id)
  GROUP BY
    event_id),
  --
  -- Join the original encounters each with their authorization status. 
  --
  complete_encounter_with_authorizations AS (
  SELECT
    encounter.*,
    authorization.is_authorized,
    authorization.authorization_status,
    authorization.region_authorizations
  FROM
    complete_encounter_event AS encounter
  INNER JOIN
    encounter_authorizations AS authorization
  USING
    (event_id)),
  --
  -- Main events query
  --
  result AS (
  SELECT
    event_id,
    'encounter' AS event_type,
    vessel_id,
    start_time AS event_start,
    end_time AS event_end,
    mean_latitude AS lat_mean,
    mean_longitude AS lon_mean,
    mean_latitude AS lat_min,
    mean_latitude AS lat_max,
    mean_longitude AS lon_min,
    mean_longitude AS lon_max,
    TO_JSON_STRING( STRUCT( ROUND(median_distance_km,3) AS median_distance_km,
        ROUND(median_speed_knots,3) AS median_speed_knots,
        encountered_vessel_id,
        elevation_m,
        distance_from_shore_m,
        distance_from_port_m,
        is_authorized,
        authorization_status,
        region_authorizations,
        STRUCT(regions.eez,
          regions.fao,
          regions.rfmo) AS regions ) ) AS event_info,
    TO_JSON_STRING([ STRUCT( vessel_id AS `id`,
      IF
        (vessel_is_carrier,
          'carrier',
          'fishing') AS `type`,
        main_vessel_ssvid AS `ssvid`,
        main_vessel_shipname AS `name`,
        main_vessel_flag AS `flag`,
        STRUCT(main_vessel_trip_start_anchorage_id AS anchorage_id,
          generate_port_id(main_vessel_trip_start_iso3,
            main_vessel_trip_start_label) AS port_id,
          main_vessel_trip_start_iso3 AS iso,
          main_vessel_trip_start_label AS label) AS origin_port,
        STRUCT(main_vessel_trip_end_anchorage_id AS anchorage_id,
          generate_port_id(main_vessel_trip_end_iso3,
            main_vessel_trip_end_label) AS port_id,
          main_vessel_trip_end_iso3 AS iso,
          main_vessel_trip_end_label AS label) AS destination_port ),
      STRUCT( encountered_vessel_id AS `id`,
      IF
        (encountered_vessel_is_carrier,
          'carrier',
          'fishing') AS `type`,
        encountered_vessel_ssvid AS `ssvid`,
        encountered_vessel_shipname AS `name`,
        encountered_vessel_flag AS `flag`,
        STRUCT(encountered_vessel_trip_start_anchorage_id AS anchorage_id,
          generate_port_id(encountered_vessel_trip_start_iso3,
            encountered_vessel_trip_start_label) AS port_id,
          encountered_vessel_trip_start_iso3 AS iso,
          encountered_vessel_trip_start_label AS label) AS origin_port,
        STRUCT(encountered_vessel_trip_end_anchorage_id AS anchorage_id,
          generate_port_id(encountered_vessel_trip_end_iso3,
            encountered_vessel_trip_end_label) AS port_id,
          encountered_vessel_trip_end_iso3 AS iso,
          encountered_vessel_trip_end_label AS label) AS destination_port ) ]) AS event_vessels,
    ST_GEOGFROMTEXT(CONCAT('POINT (', CAST(mean_longitude AS string), ' ', CAST(mean_latitude AS string), ')')) AS event_geography
  FROM
    complete_encounter_with_authorizations )
SELECT
  *
FROM
  result

#standardSQL

-- Include some utility functions
{% include 'util.sql.j2' %}

WITH

  #
  # Source tables
  #

  source_loitering AS (
    SELECT
        *
    FROM
        `{{ source_loitering }}`
    WHERE
        loitering_start_timestamp BETWEEN '{{ start_date }}' AND '{{ end_date }}'
  ),

  source_segment_info AS (
    SELECT
        *
    FROM
        `{{ source_segment_info }}`
  ),

  source_spatial_measures AS (
    SELECT
        *
    FROM
        `{{ source_spatial_measures }}`
  ),

  source_research_segs AS (
    SELECT
      *
    FROM
      `{{ source_research_segs }}`
  ),

  #
  # Vessels byyear sources
  #
  source_support_vessels AS (
    SELECT
      year,
      mmsi AS ssvid,
      'support' AS class
    FROM
        `{{ source_support_vessels_byyear }}`
  ),

  source_carriers_vessels AS (
    SELECT
        year,
        mmsi AS ssvid,
        'carrier' AS class
    FROM
        `{{ source_carrier_vessels_byyear }}`
  ),

  source_fishing_vessels AS (
    SELECT
        year,
        ssvid,
        'fishing' AS class
    FROM
        `{{ source_fishing_vessels_byyear }}`
  ),

  source_vessel_info AS (
    SELECT *
    FROM
        `{{ source_vessel_info }}`
  ),

  #
  # Unify support, carriers and support vessels in one table
  #
  # Hannah said:
  # the support vessels were manually checked by TMT, but we likely estimated some as fishing
  # We could change the fishing vessel subquery to say AND NOT IN support vessel list.
  # If we concat the ssvid codes and years to avoid losing vessels in others years

  support_carrier_and_fishing_vessels AS (
        SELECT * FROM source_carriers_vessels
        UNION ALL
        SELECT *
        FROM source_fishing_vessels fishing_vessel
        WHERE CONCAT(ssvid, '-', year) NOT IN (
                SELECT CONCAT(ssvid,'-', year)
                FROM source_support_vessels support_vessel
                WHERE support_vessel.ssvid = fishing_vessel.ssvid
                    AND support_vessel.year = fishing_vessel.year
            )
            AND CONCAT(ssvid, '-', year) NOT IN (
                SELECT CONCAT(ssvid,'-', year)
                FROM source_carriers_vessels carrer_vessel
                WHERE carrer_vessel.ssvid = fishing_vessel.ssvid
                    AND carrer_vessel.year = fishing_vessel.year
            )
        UNION ALL
        SELECT * FROM source_support_vessels
  ),

  #
  # Populate the basic info for all vessels (including vessels are not support, carrier or fishing)
  #

  support_carrier_and_fishing_with_id AS (
    SELECT
        vessel_info.vessel_id,
        vessel_info.shipname,
        vessel_info.ssvid,
        `world-fishing-827.udfs.mmsi_to_iso3`(vessel_info.ssvid) AS flag,
        vessels.year,
        class
    FROM source_vessel_info vessel_info
     JOIN support_carrier_and_fishing_vessels vessels ON (
            vessel_info.ssvid = vessels.ssvid AND
            (vessels.year BETWEEN EXTRACT(YEAR FROM vessel_info.first_timestamp) AND EXTRACT(YEAR FROM vessel_info.last_timestamp))
      )
  ),

  all_vessels_with_id AS (
      SELECT * FROM support_carrier_and_fishing_with_id
      UNION ALL
      SELECT
        vessel_info.vessel_id,
        vessel_info.shipname,
        vessel_info.ssvid,
        `world-fishing-827.udfs.mmsi_to_iso3`(vessel_info.ssvid) AS flag,
        null AS year,
        'other' AS class
      FROM source_vessel_info vessel_info WHERE vessel_id NOT IN (SELECT vessel_id FROM support_carrier_and_fishing_with_id)
  ),

  #
  # We have one row for each vessel/year. We need to deduplicate them
  #
  all_vessels_with_id_deduplicated AS (
      SELECT distinct vessel_id, shipname.value, ssvid, flag, class
      FROM all_vessels_with_id
  ),

  #
  # Build a set of good segments
  #
  good_segments AS (
    SELECT
      seg_id
    FROM
      source_research_segs
    WHERE
      good_seg
      AND NOT overlapping_and_short
  ),

  #
  # Restrict the source loitering table to denoised events
  #
  denoised_loitering AS (
    SELECT
      loitering.*
    FROM
      source_loitering loitering
    INNER JOIN
      good_segments
    USING
      (seg_id)
    WHERE
      avg_distance_from_shore_nm >= {{ minimum_distance_from_shore_nm }}
  ),

  #
  # Get base info, populate vessel info, and calculate vessel_id, lat_mean,
  # lot_mean and convert distances to km
  #
  base_loitering_event AS (
    SELECT
        TO_HEX(MD5(FORMAT("%s|%s|%t|%t",'loitering', vessel_id, loitering_start_timestamp, loitering_end_timestamp))) AS event_id,
        'loitering' AS event_type,
        vessel_id,
        seg_id,
        loitering_start_timestamp AS event_start,
        loitering_end_timestamp AS event_end,
        (start_lat + end_lat) / 2 AS lat_mean,
        (start_lon + end_lon) / 2 AS lon_mean,
        start_lat AS lat_min,
        start_lon AS lon_min,
        end_lat AS lat_max,
        end_lon AS lon_max,
        TO_JSON_STRING(STRUCT( loitering_hours,
            convert_nm_to_km(tot_distance_nm) AS total_distance_km,
            convert_nm_to_km(avg_distance_from_shore_nm) AS avg_distance_from_shore_km,
            avg_speed_knots,
            vessel.class as vessel_class
            )
        ) AS event_info,
        TO_JSON_STRING([STRUCT( vessel_id AS `id`,
            lo.ssvid AS `ssvid`,
            si.shipname.value AS `name`,
            seg_id)]
        ) AS event_vessels
    FROM denoised_loitering AS lo JOIN source_segment_info si USING (seg_id)
        JOIN all_vessels_with_id_deduplicated vessel USING (vessel_id)
  )


#
# Finally, enhance the event with info related to regions and distances.
#
SELECT
  event_id,
  event_type,
  vessel_id,
  seg_id,
  event_start,
  event_end,
  lat_mean,
  lon_mean,
  lat_min,
  lon_min,
  lat_max,
  lon_max,
  spatial_measures_mean.regions AS regions_mean_position,
  convert_m_to_km( spatial_measures_start.distance_from_shore_m ) AS start_distance_from_shore_km,
  convert_m_to_km( spatial_measures_end.distance_from_shore_m ) AS end_distance_from_shore_km,
  convert_m_to_km( spatial_measures_start.distance_from_port_m ) AS start_distance_from_port_km,
  convert_m_to_km( spatial_measures_end.distance_from_port_m ) AS end_distance_from_port_km,
  event_info,
  event_vessels
FROM
  base_loitering_event
JOIN
  source_spatial_measures AS spatial_measures_start
ON
  format_gridcode(lon_min,
    lat_min) = spatial_measures_start.gridcode
JOIN
  source_spatial_measures AS spatial_measures_end
ON
  format_gridcode(lon_max,
    lat_max) = spatial_measures_end.gridcode
JOIN
  source_spatial_measures AS spatial_measures_mean
ON
  format_gridcode(lon_mean,
    lat_mean) = spatial_measures_mean.gridcode
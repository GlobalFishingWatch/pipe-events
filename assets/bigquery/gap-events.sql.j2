#standardSQL
INSERT INTO
  `{{ dest }}` ( event_id,
    event_type,
    vessel_id,
    event_start,
    event_end,
    lat_mean,
    lon_mean,
    lat_min,
    lat_max,
    lon_min,
    lon_max,
    event_info,
    event_vessels,
    event_geography )
WITH
  #
  # Individual positional messages
  #
  message AS (
  SELECT
    seg_id,
    timestamp,
    lat,
    lon,
    distance_from_shore_m
  FROM
    `{{source}}*`
  WHERE
    _TABLE_SUFFIX BETWEEN FORMAT_DATE('%Y%m%d', DATE_SUB( DATE '{{ start_date }}', INTERVAL 1 DAY) )
    AND FORMAT_DATE('%Y%m%d', DATE_ADD( DATE '{{ end_date }}', INTERVAL 1 DAY) ) ),
  #
  # Vessel_ids for each seg_id. NB the vessel_id that is in the mssages have
  # some problems, so ignore this and get the vessel_id from the segment_vessel
  # table
  #
  best_segment_vessel AS (
  SELECT
    DISTINCT seg_id,
    FIRST_VALUE(vessel_id) OVER (PARTITION BY seg_id ORDER BY last_date DESC, vessel_id) AS vessel_id
  FROM
    `{{ segment_vessel }}` ),
  #
  # Extract seg_ids from the messages and filter to only segments that have the
  # minimum number of positions
  #
  segment AS (
  SELECT
    seg_id,
    COUNT(*) AS message_count
  FROM
    message
  GROUP BY
    seg_id
  HAVING
    message_count >= {{ min_pos_count }} ),
  #
  # Filter messages to only ones in the filtered segments
  # and add in vessel_id
  #
  filtered_message AS (
  SELECT
    *
  FROM
    message m
  JOIN
    segment
  USING
    (seg_id)
  JOIN
    best_segment_vessel
  USING
    (seg_id) ),
  #
  # Get prev and next timestamps within a vessel_id
  #
  lead_lag_message AS (
  SELECT
    *,
    LEAD(timestamp) OVER (PARTITION BY vessel_id ORDER BY timestamp) AS next_timestamp,
    LAG(timestamp) OVER (PARTITION BY vessel_id ORDER BY timestamp) AS prev_timestamp
  FROM
    filtered_message ),
  #
  # Detect transponder off events
  #
  off_message AS (
  SELECT
    *,
    'TRANSPONDER_OFF' AS event_type
  FROM
    lead_lag_message
  WHERE
    DATE(timestamp) BETWEEN DATE '{{ start_date }}'
    AND DATE '{{ end_date }}'
    AND (next_timestamp IS NULL
      OR TIMESTAMP_DIFF(next_timestamp, timestamp, HOUR) >= 24)
    AND distance_from_shore_m >= {{ min_dist }} ),
  #
  # Detect transponder on events
  #
  on_message AS (
  SELECT
    *,
    'TRANSPONDER_ON' AS event_type
  FROM
    lead_lag_message
  WHERE
    DATE(timestamp) BETWEEN DATE '{{ start_date }}'
    AND DATE '{{ end_date }}'
    AND (prev_timestamp IS NULL
      OR TIMESTAMP_DIFF(timestamp, prev_timestamp, HOUR) >= 24)
    AND distance_from_shore_m >= {{ min_dist }} ),
  #
  # Assemble a list of all transponder on and off events
  #
  raw_events AS (
  SELECT
    *
  FROM
    off_message
  UNION ALL
  SELECT
    *
  FROM
    on_message ),
  #
  # Generate a list of off events with the corresponding on event, if it exists
  #
  events_with_leads AS (
  SELECT
    *,
    LEAD(event_type) OVER (PARTITION BY vessel_id ORDER BY timestamp) AS next_event_type,
    LEAD(timestamp) OVER (PARTITION BY vessel_id ORDER BY timestamp) AS next_event_timestamp,
    LEAD(lat) OVER (PARTITION BY vessel_id ORDER BY timestamp) AS next_lat,
    LEAD(lon) OVER (PARTITION BY vessel_id ORDER BY timestamp) AS next_lon
  FROM
    raw_events ),
  #
  # Clean up the list of events by taking only off events, and their
  # corresponding on event if it exists
  #
  clean_events AS (
  SELECT
    *
  FROM
    events_with_leads
  WHERE
    event_type = 'TRANSPONDER_ON'
    AND (next_event_type = 'TRANSPONDER_OFF'
      OR next_event_type IS NULL) ),

  #
  # Include basic vessel information on the event
  #
  complete_gap_event AS (
    SELECT
      event.*,
      vessel.shipname.value AS main_vessel_shipname,
      vessel.ssvid AS main_vessel_ssvid
    FROM
      clean_events AS event
    LEFT JOIN
      `{{ vessel_info }}` as vessel
    USING
      (vessel_id) )
#
# assemble the event output
#
SELECT
  TO_HEX(MD5(FORMAT('%s|%s|%t', event_type, vessel_id, timestamp))) AS event_id,
  'gap' AS event_type,
  vessel_id,
  timestamp AS event_start,
  next_event_timestamp AS event_end,
  IFNULL((lat + next_lat) / 2, lat) AS lat_mean,
  IFNULL((lon + next_lon) / 2, lon) AS lon_mean,
  lat AS lat_min,
  IFNULL(next_lat, lat) AS lat_max,
  lon AS lon_min,
  IFNULL(next_lon, lon) AS lon_max,
  TO_JSON_STRING(STRUCT(
      STRUCT(message_count) AS stats,
      distance_from_shore_m
  )) AS event_info,
  TO_JSON_STRING([STRUCT(
    vessel_id AS `id`,
    main_vessel_ssvid AS `ssvid`,
    main_vessel_shipname AS `name`
  )]) as event_vessels,
  IF( next_lat IS NULL OR next_lon IS NULL,
    ST_GEOGFROMTEXT(CONCAT('POINT (', CAST(lon AS string), ' ', CAST(lat AS string), ')')),
    ST_GEOGFROMTEXT(CONCAT(
      'MULTIPOINT (',
      CAST(lon AS string),
      ' ',
      CAST(lat AS string),
      ', ',
      CAST(next_lon AS string),
      ' ',
      CAST(next_lat AS string),
      ')'
    )) ) AS event_geography
FROM
  complete_gap_event

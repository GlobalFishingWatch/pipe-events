#standardSQL

-- Include some utility functions
{% include 'util.sql.j2' %}

WITH 
    --
    -- Now aggregate all the messages that are in the same range into a single event record
    -- Filter out short events or events where vessel is moving too fast
    --
    fishing_event AS (
        SELECT
            ssvid,
            seg_id,
            vessel_id,
            main_vessel_shipname,
            main_vessel_flag,
            best_best_vessel_class,
            ST_CENTROID(ST_UNION_AGG(point)) AS centroid,
            ARRAY_AGG(struct(point as point, S2_CELLIDFROMPOINT(point, s2_level()) as s2_cell)) as geo_info,
            -- compute centoid of all the lat/lon pairs in the event
            event_start,
            MAX(timestamp) AS event_end,
            MIN(lat) AS lat_min,
            MAX(lat) AS lat_max,
            MIN(lon) AS lon_min,
            MAX(lon) AS lon_max,
            MIN(anti_lon(lon)) AS anti_lon_min,
            -- Also get min/max for the anti_longitude (180 degrees opposite) to deal wiht dateline crossing
            MAX(anti_lon(lon)) AS anti_lon_max,
            -- calculate number of positions, and average vessel speed during event
            COUNT(*) AS message_count,
            AVG(speed_knots) AS avg_speed_knots,
            -- remove first implied_speed_knots value in each event summary as value comes from previous position not part of event
            AVG(CASE WHEN
                             event_start = timestamp THEN NULL
                     ELSE implied_speed_knots END) AS avg_implied_speed_knots,
            -- remove first meters_to_prev value in each event summary as value comes from previous position not part of event
            AVG(CASE WHEN
                             event_start = timestamp THEN NULL
                     ELSE meters_to_prev END) AS avg_meters_to_prev,
            SUM(CASE WHEN
                             event_start = timestamp THEN NULL
                     ELSE meters_to_prev END) AS event_distance_m,
            -- remove first hours value in each event summary as value comes from previous position not part of event
            AVG(CASE WHEN
                             event_start = timestamp THEN NULL
                     ELSE hours END) AS avg_hours,
            STRING_AGG(CONCAT(CAST(lon AS string), ' ', CAST(lat AS string)), ', ' ORDER BY timestamp) AS points_wkt
        FROM
            fishing_event_message
        GROUP BY
            ssvid,
            seg_id,
            vessel_id,
            main_vessel_shipname,
            main_vessel_flag,
            best_best_vessel_class,
            event_start
        -- exclude events too short or with too high an avg vessel speed
        HAVING
            -- fishing events must be longer than 20 minutes
            (TIMESTAMP_DIFF(event_end, event_start, SECOND) > 1200
                -- fishing events must include more than 5 ais positions in event
                AND message_count > 5
                -- event average speed must be less than 10 knots
                AND avg_speed_knots < 10)
    ),

    --
    -- Correct lon_min and lon_max for crossing the dateline (anti-meridian)
    -- And extract lat and lon from the centriod
    --
    fishing_event_dateline AS (
        SELECT
            * EXCEPT (centroid,
            lon_min,
            lon_max,
            anti_lon_min,
            anti_lon_max),
            -- Get the lat and lon from the computed centroid
            geopoint_to_struct(centroid).lat AS lat_mean,
            geopoint_to_struct(centroid).lon AS lon_mean,
            -- determine which direction around the globe is shorter - across the equator (eg -1.0 to 1.0), across the
            -- dateline (eg -179.0 to 179.0) or neither (eg 10.0 to 12.0).  Use this to select which values to use for
            -- min and max longitude
            IF ( (lon_max - lon_min) <= (anti_lon_max - anti_lon_min),
                 lon_min,
                 anti_lon(anti_lon_max) ) AS lon_min,
            IF ( (lon_max - lon_min) <= (anti_lon_max - anti_lon_min),
                 lon_max,
                 anti_lon(anti_lon_min) ) AS lon_max
        FROM
            fishing_event ),

    --
    -- remove events that are too short
    --
    complete_fishing_event AS (
        SELECT
            *,
            TO_HEX(MD5(FORMAT("%s|%s|%t|%t",'fishing', vessel_id, event_start, event_end))) AS event_id
        FROM
            fishing_event_dateline
        WHERE
           -- squid jigger fishing events must be longer than 50 meters
                    best_best_vessel_class = 'squid_jigger' AND event_distance_m > 50
           -- all other fishing events must be longer than 500 meters
           OR NOT best_best_vessel_class = 'squid_jigger' AND event_distance_m > 500)

select * from complete_fishing_event
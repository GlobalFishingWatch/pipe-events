#standardSQL


INSERT INTO
  `{{ dest }}` ( event_id,
    event_type,
    vessel_id,
    event_start,
    event_end,
    lat_mean,
    lon_mean,
    lat_min,
    lat_max,
    lon_min,
    lon_max,
    event_info,
    event_geography )

WITH

  #
  # get position messages
  #
  message AS (
  SELECT
    seg_id,
    timestamp,
    lat,
    lon,
    distance_from_shore_m
  FROM
    `{{source}}*`
  WHERE
    _TABLE_SUFFIX BETWEEN FORMAT_DATE("%Y%m%d", DATE_SUB( DATE "{{ start_date }}", INTERVAL 1 DAY) )
    AND FORMAT_DATE("%Y%m%d", DATE_ADD( DATE "{{ end_date }}", INTERVAL 1 DAY) )
  ),

  #
  # get vessel_ids for each seg_id.
  # NB the vessel_id that is in the mssages have some problems, so ignore this and get the vessel_id from the segment_vessel table
  #
  best_segment_vessel AS (
    SELECT
      DISTINCT seg_id,
      FIRST_VALUE(vessel_id) OVER (PARTITION BY seg_id ORDER BY last_date DESC, vessel_id) AS vessel_id
    FROM
      `{{ segment_vessel }}`
  ),

  #
  # extract seg_ids from the messages and filter to only segments that have the minimum number of positions
  #
  segment AS (
  SELECT
    seg_id,
    COUNT(*) AS pos_count
  FROM
    message
  GROUP BY
    seg_id
  HAVING
    pos_count >= {{ min_pos_count }}
  ),

  #
  # filter messages to only ones in the filtered segments
  # and add in vessel_id
  #
  filtered_message AS (
  SELECT
    *
  FROM
    message m
  JOIN segment
    USING (seg_id)
  JOIN best_segment_vessel
    USING (seg_id)
  ),


   #
   # get prev and next timestamps within a vessel_id
   #
  lead_lag_message AS (
  SELECT
    *,
    LEAD(timestamp) OVER (PARTITION BY vessel_id ORDER BY timestamp) AS next_timestamp,
    LAG(timestamp) OVER (PARTITION BY vessel_id ORDER BY timestamp) AS prev_timestamp
  FROM
    filtered_message
  ),

  #
  # detect transponder off events
  #
  off_message AS (
  SELECT
    *,
    "TRANSPONDER_OFF" AS event_type
  FROM
    lead_lag_message
  WHERE
    DATE(timestamp) BETWEEN DATE "{{ start_date }}"
    AND DATE "{{ end_date }}"
    AND (next_timestamp IS NULL
      OR TIMESTAMP_DIFF(next_timestamp, timestamp, HOUR) >= 24)
    AND distance_from_shore_m >= {{ min_dist }}
  ),

  #
  # detect transponder on events
  #
  on_message AS (
  SELECT
    *,
    "TRANSPONDER_ON" AS event_type
  FROM
    lead_lag_message
  WHERE
    DATE(timestamp) BETWEEN DATE "{{ start_date }}"
    AND DATE "{{ end_date }}"
    AND (prev_timestamp IS NULL
      OR TIMESTAMP_DIFF(timestamp, prev_timestamp, HOUR) >= 24)
    AND distance_from_shore_m >= {{ min_dist }}
  )

#
# assemble the event output
#
SELECT
  TO_HEX(MD5(FORMAT("%s|%s|%t", event_type, vessel_id, timestamp))) AS event_id,
  event_type,
  vessel_id,
  timestamp AS event_start,
  timestamp AS event_end,
  lat AS lat_mean,
  lon AS lon_mean,
  lat AS lat_min,
  lat AS lat_max,
  lon AS lon_min,
  lon AS lon_max,
  TO_JSON_STRING(STRUCT( distance_from_shore_m,
      pos_count )) AS event_info,
  ST_GEOGFROMTEXT(CONCAT('POINT (', CAST(lon AS string), ' ', CAST(lat AS string), ')')) AS event_geography
FROM (
  SELECT
    *
  FROM
    off_message
  UNION ALL (
    SELECT
      *
    FROM
      on_message))
